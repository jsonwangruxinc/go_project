### sync/atomic 底层原子级内存操作
1. 可用于连接池（grpc ,客户端，网络连接等）等场景
#### sync.Pool 注意事项
1. 用于缓存一些创建成本很高，使用比较频繁的对象
2. Pool的长度默认为机器cpu线程数
3. 存储在Pool中的对象随时都可能在不被通知的情况下回收
4. 没有什么创建成本的对象不建议使用对象池

#### sync.Once 作用
1. 用来初始化单例资源

#### sync.Once 使用场景
1. 单例场景
2. 仅加载一次的数据懒加载场景

#### sync/atomic 作用
1. atomic包提供底层的原子级内存操作，用于实现同步算法

#### 应用场景
1. 通过内存实现通信

#### 注意事项
1. atomic属于底层原子操作，如无必要请使用通道或者sync包的其他函数或者类型实现同步算法。
2. 如果没有把握正确使用atomic那么请不要使用

### sync 同步原有包里面的锁,以及线程安全的集合
1. 应用于一发多收的场景，即一组协程需要等待某一个协程完成一些前置准备的情况
#### sync.Cond注意事项
1. 被叫方必须持有锁
2. 主叫方可以持有锁，但允许不持有
3. 尽可能的减少无效唤醒

#### Mutex 与 RWMutex 的作用
1. 并发场景下，通过锁机制，解决数据竞争的问题

#### Mutex 与 RWMutex 应用场景
1. 协程安全
2. 数据竞争

#### 注意事项
1. 尽量避免使用锁
2. 应合理使用锁机制，不能滥用

#### sync.map
1. 一个线程安全集合，内部通过原子访问和锁机制实现结合的线程安全

#### sync.map 应用场景
1. 适合读多写少的应用场景
2. 在key值已存在情况下，可以无锁修改其value，比普通map +锁 性能更好



